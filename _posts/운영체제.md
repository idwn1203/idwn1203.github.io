#컴퓨터 시스템
##구성요소
###하드웨어
###소프트웨어

	메모리와 프로그램
- Thread<Process< File< I/O
- 
---
	프로그램동작

-	명령어실행
	-	명령어구성 : Operation Code(연산코드)와 Operand(오퍼랜드)
-	인터럽트 동작
	- 인터럽트 구성 : 인터럽트 요청 인터럽트 서비스 루틴
	- 인터럽트 처리과정 :
- Disk부팅 -> 메모리 저장 

---
	고급 언어로 작성한 프로그램의 실행


어셈블러: 어셈블리 언어 프로그램을 기계어로 변환(번역프로그램)

	기계어 명령 
- object명령 단위로 인터럽트 걸 수 있다.
- 한기계어 인터럽트 안걸림
- ex) + - * /
---
컴파일러: 고급 언어를 기계어로 변환
컴파일 단계(컴파일링): (소스코드)->렉서->(토큰)->파서->(추상 구문 트리)->중간 코드 생성기->(저수준 언어)->옵티마이저->(저수준 언어)->코드 생성기->(기계 명령어)
-렉서: 프로그램의 문자들을 토큰으로 분리
-파서: 토큰을 구문적으로 올바른 문장으로 변환
-옵티마이저: 코드의 실행 효율을 높이고 메모리 요구량을 줄임
-코드 생성기: 기계어 명령어를 담고 있는 오브젝트 파일 생성

고급 언어:(포트란>코볼>파스칼,C,에이다>C++>자바>C# [개발순서])
-포트란: 복잡한 수학 계산, 과학 및 엔지니어링 분야 개발 목적
-코볼: 비즈니스 응용 프로그램 개발 목적
-파스칼: 구조적 프로그래밍을 교육할 목적
-C: 유닉스 운영체제를 개발한 언어
-에이다: 병행 프로그래밍을 지원한 최초의 언어
-C++: 객체지향 프로그래밍을 지원
-자바: 웹 비즈니스 분야에서 널리 사용
-C#: 객체지향 언어 지원, 강력한 라이브러리 컴포넌트 지원

링킹: 프로그램에서 참조하는 다양한 모듈을 실행 가능한 한 단위로 통합
-모듈: 독립적으로 개발된 몇 개의 하위 프로그램
-라이브러리: 미리 컴파일된 모듈 패키지
-링킹단계:[1]각 모듈의 크기를 결정하고 심볼 테이블을 형성
-링킹단계:[2]링커가 다른 명령어와 데이터에 주소를 부여하고 외부 심볼 참조를 결정


-	Compile - LInk - Load 
    	- Compile : 
    		- 기능 : 고급언어 -> 기계어
    		- 단계 : 렉서-> 파서 > 중간 코드 생성기 -> 옵티마이저 >코드 생성기
    	- Link
    		- 프로그램에서 참조하는 다양한 모듈을 실행 가능한 한 단위로 통합하는 과정	 
		- Load : 프로그래머나 컴파일러가 명시한 주소에 배치

로딩
->로더: 명령어와 데이터 유닛을 특정 메모리 주소에 배치
->절대 로딩: 프로그래머나 컴파일러가 명시한 주소에 배치
->재배치 가능한 로딩: 실제 메모리 주소로 변환해야 하는 상대 주소를 포함할 때 수행
->동적 로딩: 프로그램의 모듈을 처음 사용하는 시점에 로딩하는 기술



->재배치 가능한 로딩: 실제 메모리 주소로 변환해야 하는 상대 주소를 포함할 때 수행
->동적 로딩: 프로그램의 모듈을 처음 사용하는 시점에 로딩하는 기술


		- 
---
	펌웨어
   -	정의 :읽기 전용 메모리가 부착된 영구 저장소에 저장되는 실행 가능한 명령어들
   -	특징 : 마이크로프로그래밍(기계어보다 아래에 있는 프로그래밍 계층)으로 프로그래밍
   -	펌웨어(읽기 전용 메모리가 부착된 영구 저장소에 저장되는 실행 가능한 명령어들)
->마이크로프로그래밍(기계어보다 아래계층)으로 프로그래밍



---
	미들웨어
   - 정의 : 분산 시스템을 위한 소프트웨어
   - 기능 : 한 컴퓨터에서 실행하는 응용 프로그램이 원격 ㅓㅁ퓨터에서 실행하는 다른 응용 프로그램과 통신 할 수 있게함
   -  네트워크에 있는 여러 컴퓨터에서 실행되는 여러 프로세스가 통신할 수 있게 해준다.
->이기종 컴퓨터 플랫폼에서 응용 프로그램이 실행가능
---		
#하드웨어 운영체제 지원

부트 스트랩핑

	정의
	- 운영체제를 메모리에 로드하는 과정 ==부팅
	- HDD->프로그램실행-> 메모리에 올라감 == 동작
	- 작은->큰->전체
	- power on resit ->interpret vector ->Harde에서 긁어옴 
	- Rom에 깔려서 Main 에서 커널 읽어옴
---
	목적
	- 운영체제를 적재하는것 (시스템 초기화시키는것)
	- 초기화의 목적 : 운영체제 정리/ 사용자와 대화를 통한 시간 등 설정 명령해석기 적재와 준비
	- -2차 저장소의 부트 섹터에서 명령어들을 읽어 메인 메모리에 로드
* 시스템을 로드하지 못하면, 컴퓨터의 어떤 하드웨어에도 접근 불가능
---
	주체
    - 바이오스 
---
	한계
    - 시스템을 로드하지 못하면, 컴퓨터의 어떤 하드웨어에도 접근 불가능
#하드웨어 구성요소

##하드웨어 메모리계층
	레지스터
	캐시
    캐싱과 버퍼링
->캐시(고속 메모리)
-캐시 적중(cache hit)-참조하는 정보가 캐시 메모리에 있는 경우
-캐시 실패(cache miss)-참조하는 정보가 메모리에 없는 경우
-메모리 참조의 상당수가 캐시 적중되어야 성능 향상 가능
->버퍼(서로 다른 속도로 동작하는 프로세스들 사이에 데이터를 임시 보관할 저장 영역)
-소프트웨어와 하드웨어 장치들이 데이터 비동기적 전송(시스템 성능향상)
->스풀링(한 프로세스와 저속 또는 버퍼가 제한된 입출력 장치 사이에 중간 매개체를 두는 기술)

---
	메인메모리
  	 종류  
        동적램 : 재생 회로 필요 
        정적램 : 재생 회로 불필요
---
                
	자기디스크
---
	광학디스크
---
	광학디스크
---

	자기테이프
---
2차저장소
* 휘발성 매체 - 전원을 끄면 데이터 사라짐 -레지스터 캐시,메인메모리

	기능
    	버퍼 : 장치들 사이 혹은 프로세스들 사이에서 데이터 전송할때 임시로 데이터 보관하는 "저장" 영역
        스풀링 : 한프로세스와 제한도니 입출력 장치 사이에 디스크와 같은 중간 매개체를 두는 기술
---
	가상메모리(논리적주소 )와 메인메모리(물리적 주소)
    
##입출력장치
##클록

	버스
		내부버스
    	외부버스
##DMA(Direct Memory Access == 직접 메모리 접근)
##주변장치
##프로세서
###프로세서와 프로세스
Processor 는 하드웨어적인 측면에서 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛
==cpu 하나이상의 ALU와 처리 레지스터를 내장하고 있어야한다.
소프트 웨어적으로 프로세서라 함은 데이터 포맷을 변환하는 역할을 수행하는 데이터 프로세싱 시스템 데이터 처리 시스템을 의미하며 출력 가능한 인쇄물을 생성하는 워드프로세서도 프로세서라 부른다.
프로세스 특정목적을 수행하기 위해 나열된 작업의 목록
프로세스는 cpu입장에서 봣을땐 파일로 저장된 프로그램이 디스크에서 메모리로 읽어들인, 즉 장소와 포맷만 바뀌었을 뿐 스스로 실행되는 것은 아니다 그저 cpu가 실행할 과정과 실행시 참조할 데이터를 메모리에 적재해둔것에 지나지 않는다. 프로세스는 프로세서가 실행할명령어와 데이터 목록ㅇ르 메ㄹ모리에 읽어들인 것에 지나지 않는다.
파일로저장된프로그램이 메모리에 로드되고 cpu프로세서에의해 프로세스에 명시된명령어를 순서대로 cpu로 불러와 실행되는 과정을 정확하게 이해하고 있지 못하기 때문

프로세서의 기능
->대부분의 운영체제는 프로세서를 통해 보호 메커니즘을 구현.
-프로세스가 할당 받지 않은 메모리에 접근하는 것을 막음
->메모리 보호와 관리
-프로세스가 자신이 할당 받지 않은 메모리에 접근하는 것을 방지
-특권 명령어로만 수정 가능한 프로세서 레지스터를 사용해 구현
->인터럽트와 예외(폴링 사용)
-대부분의 장치는 이벤트 발생 시 프로세서에 인터럽트라는 신호를 보냄
-예외: 오류에 대한 반응으로 발생하는 인터럽트



플러그 앤 플레이
->운영체제가 새로 설치한 하드웨어를 자동으로 인식하고 사용가능하게 해줌


API(Application Programming Interface)
->응용프로그램과 운영체제 사이에 존재하여 프로그래머들이 운영체제에 서비스를 요청할 수 있는 일련의 루틴을 제공


#운영체제
##목적
	작은 의미일 경우 kernel의 뜻
- 메모리에 상주하며 응용 프로그램 실행에 필요한 환경을 설정하고 응용 프로그램 실행에 필요한 다양한 서비스를 제공하고 실행되는 프로세스를 스케줄링하는 역할


	운영체제의 주요 목적
->응용 프로그램이 하드웨어와 상호 작용할 수 있도록 돕고, 시스템 하드웨어와 소프트웨어 자원을 관리한다.

운영체제 설계 시 고려사항 : 성능, 장애 내구성, 보안, 모듈성, 비용 등

운영체제의 핵심 구성
프로세스 스케줄러: 프로세서에서 프로세스를 실행할 시점과 기간을 결정
메모리 관리자: 프로세스에 메모리를 할당할 시점과 방식, 메인메모리가 가득 찼을 때 처리 방법 결정
입출력 관리자: 하드웨어 장치들과 연동해 입출력 요청을 처리
프로세스 간 통신 관리자: 프로세스들이 서로 통신할 수 있게 한다.
파일 시스템 관리자: 저장 장치에 있는 이름 있는 데이터 모음을 조직화, 해당 데이터에 접근 할 인터페이스 제공

##운영체제의 목표

효율성(efficiency)
-	자원 효과적으로 사용하여 각 프로그램 유기적으로 결합하여 시스템 전체 성능 향상
-	처리능력
-	신뢰도
-	응답시간
-	가동률처리량이 높고 평균 처리 시간이 짧다
견고함(robustness)-장애 내구성과 신뢰성을 갖추고 있다
규모 확장성(scalability)-자원을 추가하면 해당 자원을 사용할 수 있다
확장성(extensibility)-새로운 기술에 잘 적응, 운영체제를 원래 설계보다 확장해서 더 큰 역량 발휘
이식성(portability)-다양한 하드웨어 구성에서 동작할 수 있게 설계되어 있다
보안(security)-사용자나 소프트웨어가 허가받지 않은 서비스나 시스템 자원에 접근을 예방한다
상호 작용성(interactivity)-응용프로그램이 사용자 또는 시스템에서 일어나는 이벤트에 빠르게 응답
사용성(usability)-많은 사용자 기반, 대체로 사용하기 쉬운 사용자 인터페이스를 제공한다
편리성
- 프로그램 개발하고 사용하는데 편리한 환경 제공

##역할
자원관리

	자원 종류
		프로세서
    	메모리
    	2차 저장소
    	기타 장치
    	프로세스
    	스레드
    	파일
    	데이터 베이스
    
하드웨어 & 소프트웨어 자원: 프로세서,메모리,2차 저장소,기타 장치,프로세스,스레드,파일,데이터베이스

무어의 법칙
->프로세스 성능: 18개월마다 2배 증가
->트랜지스터 수: 24개월마다 2배 증가

컴퓨터 하드웨어의 구성(프로세서, 메인메모리, 입출력 장치)
메인보드: 인쇄 회로 기판, 바이오스(하드웨어 초기화)
프로세서: 일련의 기계어 명령어를 실행하는 하드웨어 구성 요소
-CPU: 프로그램의 명령어를 실행하는 프로세서
-보조 프로세서: 특수 목적 명령어들을 효율적으로 실행(그래픽, 디지털 신호 처리기 등)
-명령어 폐치기: 명령어 레지스터에 명령어를 로드
-명령어 해석기: 명령어를 해석하고 이에 해당하는 입력 정보를 실행 처리기에 전달
-산술 논리 장치(ALU): 덧셈, 곱셈 같은 기본적인 산술 연산과 대소 비교 같은 논리 연산 수행
-캐시: 고속 메모리, 메인 메모리에 있는 데이터의 복사본을 저장하여 프로세서의 효율 향상
-레지스터: 프로세서에 위치한 고속 메모리(프로세서가 데이터를 조작하려면 해당 데이터가 레지스터에 위치해야 함)
클록: 컴퓨터 시간은 흔히 사이클(클록틱)을 통해 측정
-사이클: 시스템 클록 생성기가 보낸 전기 신호의 한 진폭
-클록 생성기는 버스가 데이터를 나르는 주기 결정
-초당 사이클 수(Hz, hertz)
* 시스템의 모든 구성요소는 각 장치의 프론트사이드 버스를 기준으로 클록 속도를 정해 작동한다.
메모리: 가장 빠르고 비싼 메모리는 최상위 계층, 가장 저렴하고 속도가 느린 메모리는 최하위 계층
- 휘발성 매체(전원끄면 데이터사라짐): [속도]:레지스터>캐시(SRAM)>메인 메모리(DRAM)
- 비 휘발성 매체(전원꺼도 데이터안사리짐): 하드 디스크, 테이프, CD, DVD 등.
- 메인메모리(임의 접근 메모리): 프로세스가 어떤 순서로든 데이터에 접근 가능
버스: 트레이스의 집합
- 트레이스: 하드웨어 장치들 간에 정보를 전송하는 아주 작은 전기적 연결선
- 포트: 정확히 두 장치를 연결하는 버스
- 입출력 채널: 서너 개 장치에서 입출력 기능을 수행할 때 공유하는 버스
- 프론트 사이드 버스(FSB): 프로세서들을 메모리 모듈에 연결
직접 메모리 접근(DMA): 메모리와 입출력 장치 간의 데이터 전송 효율 향상
- 프로세서->입출력컨트롤러->디스크,메모리컨트롤러,램->프로세서에 인터럽트
- 메인 메모리와 입출력 장치 사이에 데이터를 전송하는데 필요한 작업을 덜어주어 프로세서가 다른 명령어들을 실행할 수 있게되어, 프로그래밍된 입출력(PIO)보다 효율적
주변 장치(컴퓨터가 소프트웨어 명령어를 실행하는데 필수적이지 않은 하드웨어)

##역사(발전역사)
운영체제의 역사

	1940년	
- 운영체제를 포함하지 않음
- 어셈블리 언어(프로그래밍 속도를 향상할 목적으로 개발. 영어와 비슷한 약어 사용)
---
	1950년
- 단일 스트림 배치 처리 시스템

---
	1960년	
- 멀티 프로그래밍 시스템, 시분할 시스템
* 멀티 프로그래밍 정도(동시에 몇가지 작업을 관리할 수 있는지)
* ---
	1970년	
- 네트워크 통신분야의 발전(TCP/IP 표준 활성화)
- 
---
	1980년	
- 개인용 컴퓨터와 워크스테이션의 시대(GUI등장)
- 네트워크 기술의 발전(클라이언트/서버 컴퓨팅)
- 소프트웨어 공학 분야의 발전
- 인터넷과 WWW의 역사	HTML, HTTP의 개발
---
	1990년	
- 하드웨어 성능의 기하급수적 발전
- 분산 컴퓨팅의 증가
- 객체 기술
- 오픈 소스 운동(모든 사람이 수정 가능. 버그 수정률이 올라감)
---
	2000년이후	
- 미들웨어(네트워크 등을 통해 두 독립적인 응용 프로그램을 서로 연결하는 소프트웨어)
- 멀티프로세스와 네트워크 아키텍처, 고도 병렬성

- 응용프로그램 기반
	- 운영체제는 응용 소프트웨어 개발자들의 메모리관리 입출력 회선 관리 부담 해소
	- 응용프로그램 개발자는 특정 루틴만을 호출

##유형
	 다중 프로그래밍 시스템
		운영체제는 메모리에 있는 작업중 하나를 택하여 실행
		프로세서가 항상 수행할 작업을 가지도록 하여 프로세서 이용률 증진시키는 방법

 	시분할 시스템 TTS(Time Sharing System)
		다중 프로그래밍 시스템을 논리적으로 화장한 개념 
		다중 작업을 교대로 수행
        
	일괄 처리 시스템
    
	대화식 입출력
    
	분산처리 시스템(Distributed Processing System)
		시스템마다 운영체제와 메모리를 가지고 독립적으로 운영되며 필요할때 통신

	다중처리 시스템 
		마이크로프로세서 여러 개를 연결해 다중 프로세서를 만든다.
##운영체제 환경
	범용 컴퓨터
- 대용량 메모리와 디스크, 고속 프로세서, 주변 장치로 구성
- 개인용 컴퓨터나 워크스테이션으로 사용
- 고성능 하드웨어를 갖춘 고사양 웹 서버와 데이터베이스 서버에 적용
- 대용량 메모리와 특수 목적 하드웨어, 여러 프로세스를 지원

	임베디드 시스템    
  
- 시스템	휴대폰, PDA 같은 소형기기에 기능을 제공하는 특화된 소규모 자원
- 효율적인 자원 관리 요구, 적은 코드로 서비스 제공
- 전력관리, 사용자 친화적 인터페이스 제공
---
	실시간 시스템
    
- 정해진 시간 안에 특정 작업 완료
- ex)소프트 실시간, 하드 실시간[온도모니터시스템
---
	가상머신
    - 컴퓨터를 소프트웨어로 추상화
가상 머신 운영체제
가상 머신의 응용 프로그램(에뮬레이션:시스템에 존재하지 않는 하드웨어나 소프트웨어 기능 흉내)
여러 사용자가 하드웨어 공유(소프트웨어 이식성 향상), 실제 머신보다 효율 떨어짐
자바 가상머신(JVM / VMware)

##기능(주요역할)
- 프로세스관리
- 메모리관리
- 장치관리
- 파일관리

--> 위 기능들을 활용한 하드웨어 제어
##아키텍처
	모놀리식 아키텍처
- 효율적
- 모든 운영체제 구성요소가 커널에 포함 되어 있기 때문에 견고하고 확장적이고 보안성 있는 모놀리식 운영체제를 개발하는 것은 도전적일 수 있다
- 기능구현 -> 합체 -> 유지보수가 쉽다
- 모든 컴포넌트 커널
- 오류 코드에 취약함
	- if() -> 해킹 (무사심하게)
	- ->if else

Soft ware -> Codding X 문서(논리가중요 Syntax 즉 문법만 알면 안됨)
FP-> file Operation 위해 만들어줌 
Systemcall -read open write
##Cloud
어디숨어있는지,어디서 뽑아내는지모름- >해킹방지
수백만 PC 보드 -> 항상 고장 -> 백업
Torrent Network -->operation system 일종
---

	계층적 구조
    
- 계층적 구조는 운영체제가 보다 모듈화되어 있기 때문에 모놀리식 구조보다 더 확장적이고 디버깅이 쉽고 보다 견고하다. 그러나 계층적 구조는 효율성을 감소시킨다.
- 
---
	마이크로커널 구조
- 마이크로커널 운영체제는 많은 운영체제 컴포넌트들이 서로 독립적으로 수행되기 때문에 매우 확장적이다. 이러한 증가된 모듈화는 마이크로커널 구조의 견고성과 보안성을 증가시킬 수 있다. 그러나 이러한 고수준의 모듈화는 프로세스간 통신(interprocess communication) 오버헤드에 기인하여 다른 운영체제 구조보다는 효율성이 떨어진다.
- 소수의 서비스만 제공, 확장성 이식성, 규모 확장성이 높음
네트워크 운영체제: 프로세스들이 원격 컴퓨터의 파일과 프로세서 자원에 접근가능. 
---    
    분산 구조
- 분산 운영체제의 목표: 투명한, 성능, 규모 확장성, 장애 내구성, 일관성을 보장
- resorce,combit,Hadoop

#프로세스  

##프로세스정의
모두가 인정할 만한 정의가 없는 이유 : 
OS 마다 프로세스를 관리 및 정의하여 처리하는 것이 다르고 os별로 정의된 프로세스는 os의 시스템 상태에 적절하게 정의 및 구현 되는 것이기 때문
프로세스가 표현하기에 어려운 추상화 개념이기 때문일수도
정의도 사용환경에 따라 달라 질 수 있기 때문

###프로세스

- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- 스케줄링의 대상이 되는 작업(**task**) 와 바꿔쓸 수 있는 용어
- 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 **작업단위** 
- 실행 중인 프로그램(program in execution)
- 행중인 프로시저의 통제소재 locus of control ·현재 실행 중이거나 곧 실행할 수 있는 PCB를 가진 프로그램이다.
- 디스크에 저장되어 있던 실행 가능한 프로그램이 메모리에 적재되어 운영체제의 제어 받는상태
- 해당 프로세스가 사용되고 있는 메모리영역(자신의 주소공간)이 존재함을 의미
- 프로세스는 프로그램과 달리 메모리에 주소공간을 갖는 능동적인 개체다
---
	텍스트영역 : 프로세서가 실행하는 코드를 저장하는 영역
	데이터영역 : 변수들을 저장하는 영역과 프로세스가 실행 중에 사용하려고 동적으로 할당 받는 메모리 공간
	스택영역   : 호출된 프로시저용용으로 지역 변수와 명령어들을 저장하는 공간
---
	종류
   - 운영체제 프로세스
   	- 운영체제가 수행
   	- 프로세스 실행순서 제어
   	- 사용하고 있는 프로세스가 다른 사용자나 운영체제 영역 침범하지 못하게 감시
   	-  사용자 프로세스 생성,입출력 프로세스 등 시스템 운영에 필요한 작업 수행
   	
   - 사용자 프로세스
   	- 사용자가 수행
   	- 커널,운영체제를 통해서 제어
   - 커널 영역 프로세스 컨트롤 할 수 없음 
   	- mode가 있음
   	- 동작원리 -> 활용방안찾기!
   	- 실제 하드 다날아감->논리적 내용만 OR 임베디드시스템 
---
   	실행 내용에 따른 분류
   - 독립 프로세스
   - 협동 프로세스
   
##프로세스 동작(하드웨어관점)
BootStrapping이후
Program동작(운영체제 입장 -어떤게동작하는지)-> 메모리에 Load 
-> CPU 수행
- 1)memorydata읽어서 수행 == 디스패칭
- 2)multi _process,mult-thread
	- 동시처럼보임(워낙 빠르게 바뀌어서)
	- 

   
##프로세스상태(프로세스 생명주기),상태전이
Ready List(Queue)
- 우선순위 정보를 포함
- 리스트에서 우선순위가 가장 높은 첫 번째 프로세스가 프로세서에 할당됨

Blocked List(Queue)
- 블록된 프로세스가 기다리는 이벤트가 발생하는 순서로 블록해제
Process State
- Dispatching : 준비리스트에 있는 첫번째 프로세스에 프로세서를 할당하는것 
- 운영체제는 한 프로세스가 시스템 프로세서 독점하는 일을 방지하려고 **Interrupting Clock**(간격타이머==하드웨어 인터럽팅클록)을 두어, 프로세스가 특정시간 간격 또는 **Quantom(퀀텀)**동안만 실행할 수 있게함

Process 생명주기
- Running State(실행상태) : 프로세스가 프로세서에서 실행중
- Ready State(준비상태) : 프로세스가 프로세서에서 실행가능
- Block State(블록상태) : 프로세스가 작업을 진행하기에 앞서 특정 이벤트 발생을 대기



---
##프로세스관리
	프로세스 제어 블록/프로세스 기술자
- PCB
- PID(Process Identification)
- PRocess State (프로그램상태)
- PC(프로그램카운터)
- Scheduling Priority
- Credential
- Parent Process
- Child PRocess
- 프로세스 데이터와 명령어가 있는 메모리 위치를 가르키는 포인터
- 프로세스에 할당도니 자원들을 가르키는 포인터
---
	Process Table

- 프로세스 생성(create)
- 프로세스 소멸(destroy)
- 프로세스 일시 정지(suspend)
	- 정의 :소멸되지 않고 프로세서 차지하려고 하는 경쟁 대열에서 무기한 배제
	- 활용방안 : 악성코드 실행과 같은 보한 위협 요인 추적,디버깅할때 사용
	- 발생원인 : 해당 프로세스 혹은 다른 프로세스에 의해 발생
	- 해결 : 일시정지 블록 상태 프로세스는 다른 프로세스에 의해 재시작 가능 	
	- 상태 : SuspendedReady(일시 정지 준비 )SuspendedBlocked(일시정지 블록)
- 프로세스 재 시작(resume)
- 프로세스 우선순위 변경(change priority)
- 프로세스 블록(block)
- 프로세스 깨우기(wake up)
- 프로세스 디스패치(dispatch)
- Intercrosses communication(IPC)
---
	Contect Switching(문맥교환)
- 운영체제에 의해 실행중인 프로세스를 멈추고 준비 상태에 있던 다른 프로세스를 실행
- 실행중인 프로세스의 실행 문맥을 해당 프로세스의 PCB에 저장
- 실행할 준비 상태 프로세스의 이전 실행 문맥을 PCB에서 읽어 로드
- 기본적으로 프로세스에 투명해야함
- 문맥교환이 일어나는 동안 프로세서는 '의미있는'작업을 수행하지 못함
	- 운영체제는 문맥교환에 드는 시간을 최소화 해야함
---
	Interrupt
- 기능
	- 소프트웨어가 하드웨어로부터 오는 신호에 반응할 수 있게함
	- 프로세서는 프로세스의 명령어를 실행한 결과로 인터럽트를 발생
	- 프로세서의 현재 명령어와 관련 없는 이벤트에 의해서도 인터럽트 발생
- 종류
	- HW Interrupts
		- 소프트웨어가 하드웨어로부터 오는 신호에 반응할 수 있게함
		- EX) 키보드,마우스,클록/타이머  
    - SW Interrupts
		- 부적절한 파일 접근 또는 현재실행 중인 프로세스에 의해 발생되는 오류나 예외상황으로 발생
		- EX)보호 메모리 쓰기 ,Zero Divide
- 처리
- 
---
	Polling
- 인터럽트 대안
- 프로세서가 각 장치 상태 반복적으로 확인
- 컴퓨터 시스템 복잡도가 증가할수록 오버헤드 증가 
---
	프로세스간 통신
- 종류 : 메시지 / 신호

#Thread
##사용동기
##Thread 상태
##Thread Model

#병행실행
##상호배제


#Q1
프로세스<프로그램<시스템?
프로그램이 취할 경로?


##중요개념
1.프로세스는 개체 entity 이다-프로세서는 자신의 주소공간을 가지고 있다.

주소 공간 
텍스트 영역    
코드 저장소

데이터 영역
변수들을 저장하는 영역

힙영역 
프로세스가 실행 중에 사용하려고 동적으로 할당받은 메모리 공간
스택영역
	호출된 프로시저용으로 지역 변수와 명령어들을 저장하는 공간
스택의 내용은 프로세스가 중첩되게 프로시저 호출을 할수록 증가
호출된 프로시저가 수행을 마치고 반활할 때 감소
	
나누는 이유 : 
대부분의 프로ㅔ스 명령어 읽고 실행하지만 수정 하지 않음
프로세서 LIFO순서로 스택에서 일고씀
프로세스는 어떠 순서로든 데이터 읽고 쓸 수 있음
프로세스의 주소공간을 독립된 공간으로 분리함으로 운영체제가 그러한 접근 규칙을 강화할 수 있게한다.


Thread
커널수준 스레드와 사용자 수준 스레드에서 디스패치의 같은점과 차이점 
사용자 수준 스레드 에서는 사용자 수준 라이브러리로 프로세스의 스레드를 스케줄링하고 디스패치한다 운영체제 입장에서 프로세스가 여러 스레드를 포함하고 있따는 사실을 인식하지 못하기 때문에
장점 운영체제에서 스레드를 지원할 필요가 없다 -> 운영체제의 스레딩api에 의존하지 않고 이식성이 높아진다 자신의 응용프로긂 요구에 맞게 스레딩 라이브러리의 스ㅔ줄링 알고리즘을 수정할 수 있다.
운영체제에서 디스패치할 수 있는 커널 스레드를 각 사용자 스레드에 제공해야 한다.
커널 스레드 프로세스의 주소공간을 공유하기 때문에 중량프로세스들과는 차이가 있다.
커널이 각 스레드를 개별적으로 관리 할 수 있다. == 하나가 블록된 상태일때도 운영체제는 다른 준비 상태 스레드들을 실행할 수 있다.
운영체제의 디스패처는 커널수준 스레드를 통해 사용자 스레드를 개별적으로 인식 할 수 있다.

2. 실행중인 프로그램이다. 
프로그램은 자체로 살아있지 않는다. 프로세서가 생명ㅇㄹ 불어넣을 때 activity entity 활성개체가 된다.


멀티프로세싱멀티태스킹


시험 예상 문제
1.시스템의 모든 구성요소는 동일한 클록 속도로 작동한다. (X)
2.일반적으로 컴퓨터는 어셈블리 코드를 직접 실행한다. (X)
3.기계어 명령어보다 하위 수준인 명령어는 없다. (X)

4.다음 하드웨어 장치들이 다음 어떤 설명과 가장 잘 부합하는지 말하라. (답이 둘 이상 있을 수도 있다.)
가.메인보드	나.프로세서	다.버스
라.메모리	마.하드 디스크	바.주변 장치
사.3차 저장소	아.레지스터	자.캐시
a.프로그램의 명령어를 실행한다. [프로세서]
b.컴퓨터가 프로그램 명령어를 실행하는 데는 필요하지 않다. [버스]
c.휘발성 저장 매체다. [레지스터,캐시]
d.시스템의 프로세서를 메모리, 2차 저장소, 주변 장치 등과 연결하는 PCB다. [캐시]
e.컴퓨터 시스템에서 가장 빠른 메모리다. [레지스터]
f.하드웨어 장치 간에 데이터를 전송하는 트레이스들의 집합이다. [버스]
g.응용 프로그램의 성능을 향상시키는 빠른 메모리다. [캐시]
h.프로세서가 직접 참조할 수 있는 것 중 메모리 계층 구조에서 가장 낮은 수준의 메모리다. [3차저장소]

5.다음 목록을 가장 빠르고 비싼 메모리에서 가장 느리고 저렴한 메모리 순서로 정렬하라.
(레지스터>L1캐시>L2캐시>메인 메모리>2차 저장소>3차 저장소)

3장 프로세스 개념
프로세스
->시스템을 동작시키고 동시에 수행하는 많은 활동을 관리
->프로세스 상태를 변화

프로세스 정의: 실행 중인 프로그램(program in execution)
->주소 공간
-텍스트 영역: 프로세서가 실행하는 코드를 저장하는 영역
-데이터 영역: 변수들을 저장하는 영역, 동적으로 할당 받은 메모리 공간
-스택 영역: 호출된 프로시저용으로 지역 변수와 명령어들을 저장하는 공간

프로세스 생명 주기
->프로세스 생명 주기 동안의 구분된 프로세스 상태
-실행 상태: 프로세스가 프로세서에서 실행 중
-준비 상태: 프로세스가 프로세서에서 실행 가능
-블록 상태: 프로세스가 작업을 진행하기에 앞서 특정 이벤트 발생을 대기
->준비 리스트와 블록 리스트
-준비 리스트: 우선순위 정보를 포함, 우선순위가 가장 높은 첫 번째 프로세스가 프로세서를 할당
-블록 리스트: 블록된 프로세스가 기다리는 이벤트가 발생하는 순서로 블록 해제

프로세스 관리: 운영체제는 프로세스에 기본적인 서비스를 수행
-프로세스 생성(create) -프로세스 소멸(destroy) -프로세스 일시 정지(suspend)
-프로세스 재 시작(resume) -프로세스 우선순위 변경(change priority) -프로세스 블록(block)
-프로세스 깨우기(wake up) -프로세스 디스패치(dispatch) -Inter-Process communication(IPC)

프로세스 상태(process state)
->디스패칭(dispatching): 준비 리스트에 있는 첫 번째 프로세스에 프로세서를 할당하는 것
->인터럽팅 클록(interrupting clock): 한 프로세스가 시스템의 프로세서를 독점하는 일을 방지하는 것
프로세스 상태 전이(process state transitions)	
->네 가지 상태 전이	
-프로세서를 할당 받음: 준비상태->실행상태로 전이
-할당 받은 시간 완료: 실행상태->준비상태로 전이
-프로세스가 블록: 실행상태->블록상태로 전이
-대기하던 이벤트 완료: 블록상태->준비상태로 전이	

프로세스 제어 블록(PCB): 프로세스를 관리하는 데 필요한 정보를 보관
-프로세스 식별 번호(PID) 운영체제가 각 프로세스를 식별할 수 있게 하기 위해
-프로세스 상태
-프로그램 카운터 (프로세서가 다음에 실행할 명령어를 가리키는 값)
-스케줄링 우선순위
-권한(credential) (프로세스가 접근할 수 있는 자원을 결정하는 정보)
-부모 프로세스 (해당 프로세스를 생성한 프로세스를 가리키는 포인터)
-자식 프로세스 (해당 프로세스가 생성한 프로세스들을 가리키는 포인터)
-프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터
-프로세스에 할당된 자원들을 가리키는 포인터
프로세스 테이블: 각 프로세스의 PCB를 가리키는 포인터 리스트를 유지
->PCB에 빠르게 접근
->프로세스가 종료하면, 자원 해제 및 프로세스 테이블에서 해당 프로세스 제거

프로세스 연산
->프로세스는 새로운 프로세스를 생성(spawn)
-부모 프로세스, 자식 프로세스(한 부모를 가짐)
->프로세스가 소멸 될 경우(2가지)
-부모 프로세스가 소멸될 때 자동으로 자식 프로세스들도 소멸
-자식 프로세스가 부모에 독립적으로 계속 실행되면, 부모프로세스의 소멸이 자식에 영향을 미치지 않음 

프로세스 일시 정지
-아직 소멸되지 않고 프로세스 차지 경쟁 대열에서 무기한으로 배재
-악성 코드 실행과 같은 보안 위협 요인을 추적하거나 디버깅할 때 유용
-해당 프로세스 혹은 다른 프로세스에 의해 발생	
일시 정지 준비(suspendedready) 	
일시 정지 블록(suspendedblocked)	

문맥 교환(context switches)
->운영체제에 의해 실행 중인 프로세스를 멈추고 준비 상태에 있던 다른 프로세스를 실행하는 것을 뜻함
->실행 중인 프로세스의 실행 문맥을 해당 프로세스의 PCB에 저장
->실행할 준비 상태 프로세스의 이전 실행 문맥을 PCB에서 읽어 로드
->기본적으로 프로세스에 투명(transparent)해야 함(프로세스가 자신이 프로세서에서 제거되는 상황을 인지 못하게) * 문맥 교환이 일어나는 동안 프로세서는 ‘의미 있는’ 작업을 수행할 수 없음.
->문맥 교환은 순전히 ‘오버헤드’며 매우 빈번하게 발생, (운영체제는 문맥 교환에 드는 시간을 최소화해야함)

인터럽트(interrupts)
->소프트웨어가 하드웨어로부터 오는 신호에 반응할 수 있게 함
-프로세서는 프로세스의 명령어를 실행한 결과로 인터럽트를 발생(동기성)
-프로세서의 현재 명령어와 관련 없는 이벤트에 의해서도 인터럽트 발생(비동기성)(키보드,마우스작동)
-적은 오버헤드
-폴링(polling):인터럽트의 대안(프로세서가 각 장치의 상태를 반복적으로 확인, 복잡하면 오버헤드 증가)

인터럽트 처리
-인터럽트 컨트롤러를 통해 우선순위에 맞게 인터럽트 처리
-현재 명령어 실행을 완료하면 현재 프로세스의 실행을 멈춤
-제어 권을 적절한 인터럽트 처리기에 넘김
-인터럽트 유형을 기반으로 수행
-인터럽트 처리기 완료 후, 인트럽트 된 프로세스의 상태 복구
-인터럽트 된 프로세스 실행
프로세스 간 통신(IPC)
->멀티프로그래밍 네트워크 환경
->공통의 목적을 달성하기 위해 서로 협력

신호(Signal): 프로세스에 이벤트가 발생했음을 알리는 소프트웨어 인터럽트
->프로세스들이 다른 프로세스와 교환할 데이터를 명시하지 않음
->프로세스가 신호에 응답할 세 가지 방법: 잡음(catch), 무시(ignore), 마스킹(masking)

메시지 전달(message passing)
->분산 시스템들이 신호보다 메시지 전달에 의존
->단방향, 양방향 가능
->블록킹 송신: 수신자가 메시지를 수신할 때까지 대기
->넌블록킹 송신: 송신자가 수신자의 메시지를 안받아도 다른 작업을 계속 수행가능한 전송 방식
->파이프: 메시지 전달 구현

유닉스(UNIX) 프로세스
-가상 주소 공간(virtual address apcase)이라는 일련의 메모리 주소를 제공 받음
-PCB(프로세스 제어 블록)를 사용자 프로세스가 접근할 수 없는 보호된 메모리 영역에 유지
-유닉스 PCB
1.프로세서 레지스터의 내용
2.프로세스 식별자(PID)
3.프로그램 카운터
4.시스템 스택
-모든 프로세스는 프로세스 테이블에 리스트
-시스템 호출을 통해 운영체제와 상호 작용(fork 시스템 호출을 통한 자식 프로세스 생성)
- -20 ~ 19 사이의 정수로 프로세스 우선순위를 가짐
-데이터 통신을 위해 신호나 파이프 메커니즘 제공

OX 퀴즈
1. ‘프로세스’와 ‘프로그램’은 동의어다. (X)
2. 특정 시간에 컴퓨터에서 오직 한 프로세스만 실행할 수 있다. (X)
3. PCB 구조는 운영체제의 구현에 따라 다르다. (O)
4. 한 프로세스가 부모 프로세스를 전혀 갖지 않을 수도 있다. (O){root프로세스}

4장 스레드 개념
4.2 스레드(thread)
->프로세스 내부에 존재하는 수행 경로, 즉 일련의 실행 코드(프로세스는 단순한 껍데기일 뿐, 실제 작업은 스레드가 담당한다. 프로세스 생성 시 하나의 주 스레드가 생성되어 대부분의 작업을 처리하고 주 스레드가 종료되면 프로세스도 종료된다.
->경랑 프로세스(LWP)라고도 하며, 많은 프로세스 속성을 공유.
-프로세스에 속한 주소 공간은 해당 프로세스에 속한 모든 스레드에 공통으로 접근가능
-레지스터, 스택, 신호 마스크처럼 스레드마다 있는 특정 데이터들은 각 스레드만 접근 가능
->프로세스에 있는 스레드들은 병행으로 실행되면서(멀티스레딩) 공통의 목표를 이루려고 협력
- * 하나의 운영체제에 여러 개의 프로세스가 동시에 실행되는 환경: 멀티 태스킹
- * 하나의 프로세스 내에서 다수의 스레드가 동시에 수행되는 것: 멀티스레딩

4.3 멀티스레딩: 소프트웨어 설계, 성능, 협력부분에서 큰 효과를 나타냄

4.4 스레드 상태: 생명주기
탄생->준비->실행->종료->블록->대기->휴먼
탄생(bom)- 스레드의 생성
준비(ready)- 프로그램이 스레드를 시작 
실행(running)- 우선순위가 높은 준비 상태 스레드가 프로세서를 할당 받음
데드(dead)- 작업을 완료하거나 다른 방식으로 종료(해당 스레드는 자원 해제 및 시스템에서 제거)
블록(blocked)- 입출력 요청이 완료되기를 대기
대기(waiting)- 특정 이벤트 발생(다른 스레드의 신호나 마우스 움직임 등)
통지(notify)- 대기 상태일 때 준비상태로 바꾸라고 이벤트를 주는 것
휴먼(sleeping)- 휴면 간격이라는 일정 시간 동안 휴면 상태에 들어감

4.5 스레드 연산
->스레드와 프로세스는 공통된 많은 연산들을 소유: create, exit, resume, suspend 등
->몇몇 연산은 스레드와 프로세스가 일치하지 않음: cancel, join(결합)

4.6 스레딩 모델
사용자 수준 스레드(다대일 스레드 맵핑)
- 초기 운영체제에서 사용, 사용자 영역에서 스레드 연산을 수행
- 한 프로세스에 속한 모든 스레드가 단일 실행 문맥에 맵핑됨(사용자 영역)
커널 수준 스레드(일대일 스레드 맵핑 제공(상호작용성 증가))
- 각 스레드 마다 고유한 실행 문맥을 맵핑하는 방법으로 사용자 수준 스레드의 한계 해결
사용자 수준과 커널 수준 스레드의 조합(다대다 스레드 맵핑(m-to-m)) 
- 스레드 풀링을 통해 오버헤드 문제 해결

4.7 스레드 구현 시 고려 사항
스레드 신호 전달
- 동기 신호: 프로세스나 스레드가 실행한 명령어의 직접적인 결과로 발생
- 비동기 신호: 현재 실행하는 명령어와 무관한 다른 이벤트에서 발생
* 프로세스는 신호 마스킹을 통해 여러 스레드가 받을 신호를 나눌 수 있음
* 신호 마스킹은 운영체제가 신호를 받을 스레드를 결정할 수 있게 해줌
스레드 종료: 취소 신호 마스킹을 사용해 중단 가능
4.8 POSIX와 Pthread: POSIX 스레딩 API를 사용하는 스레드를 Pthread라고 함

4.9 리눅스 스레드(스레딩을 가능하게 하려고 clone이라는 수정된 버전의 fork 시스템 호출을 제공)

#비동기식 병행 실행
##스레드의 병행(Concurrent)
- 한 시스템에서 동시에 여러 스레드 존재
- 독립적 실행 또는 협력 실행
- 비동기적 실행(독립적으로 실행, 때로는 의사 소통하고, 동기화해 협력)

## 비동기적 병행 스레드
병행성 (Concurrency,동시성)
동기 : 같은 시간에 정확히
시작도 중요 함 : 초기화부터
현대 병렬,병행 많이씀

## 상호작용
- 프로세스는 결정성을 확보해야함
- Deadlock 발생이유
	- Blocking상태 빠짐->resource 반납불가->수행하지 않음 ->교착상태 



## 상호 배제(Mutual exclusion): 
- 어느 한 스레드가 공유 변수를 갱신하는 동안에는 다른 스레드들이 동시에 접근 방지
- 공유 변수에 대한 접근 제어 부재 시 오류 발생(즉, 스레드가 같이 동시에 공유자원에 접근할 경우)
- 각 스레드의 공유 변수에 대한 배타적인 접근(Exclusive access) 필요
- 공유 변수에 대한 순차화(Serializing) 접근
- 임계 영역: 수정 가능한 공유 데이터에 한번에 한 스레드만 특정 자원에 접근 실행 가능, 종료 정리 작업(스레드 종료 시, 상호 배제를 해제)
- 상호 배제 프리미티브: 스레드의 임계영역에서 일어나는 일을 캡슐화
- w p
- 0->0     0->0
- 1->1	   100->100
- 동시에 write -> 오류 == 힘듬
- P|A p|A    |Cw|CP|||||...
  피하나가 
  프로세스 실행시간 일정하다는 가정 -> 계산가능?
  프로세스 실행시간 바뀐다면?
  write<read빠르기
  
- 주고받기 내가 확인할때까지 지켜주는것
- 상호배제하면 임계영역 (critical section)존재
	- 임계영역 interrupt걸리지 않는 영역 
	- 방법 : 
	- 1.Disable			-> enable화 시키기 
	- 2.우선순위 미루기   -> priority 원상복귀
- 상호배제 사용하지 않으면 단순한 프로그램 
- ex)지도 ---


	Producer Consumer관계
- 생산한것만 찍어라
- 병행시키깅 위해서 공유 버퍼 필요
- 데이터 생산 속도와 소비속도가 독립적 -> 속도차 줄여야함(동기화) -> 버퍼필요 (버퍼상태는 신호로 확인할 수 있다.)
- 
    
#Q
- windows 에서Idle(useless)만수행
- apm ->Thread 여러개 
---
	상호 배제 문제에 대한 소프트웨어 해결책
데커의 알고리즘(망한 각 버전의 문제점을 살펴보자)
-1버전. 고정된 동기화와 바쁜 대기 문제 발생
-2버전. 상호 배제 위반
-3버전. 교착 상태 발생
-4버전. 무기한 연기 발생

데커의 알고리즘(다익스트라가 개선하여 적합한 해결책을 찾은 것을 살펴보자)
-선호 스레드 개념 사용(임계 영역에 여러 스레드 접근 시 먼저 진입 가능(충돌해결))
-상호 배제 보장, 교착 상태, 무기한 연기 방지
페터슨의 알고리즘(바쁜 대기, 선호 스레드를 사용해 상호 배제를 이루는 데커보다 더 간단한 알고리즘)
-바쁜 대기, 선호 스레드 사용
-상호 배제 프리미티브 수행 시, 적은 요구 단계
-스레드가 갑자기 종료 되지 않는 한, 표착 상태, 무기한 연기는 일어나지 않음
램포트의 베이커리 알고리즘(n-tread 상호 배제)
-티켓 뽑기 시스템 사용(오름차순, 티켓의 번호가 가장 낮은 스레드 실행)

	상호 배제 문제에 대한 하드웨어 해결책
인터럽트 비활성화(문제점: 스레드가 임계 영역에서 입/출력 이벤트 기다릴 때 교착상태 발생)
테스트 후 설정 명령어(읽기-수정-쓰기 메모리 연산) / 2개의 인수사용 수행후에 2번째 인수가 항상 ‘참’
*Q.testAndSet 명령어는 상호 배제를 강제한다(X)
스왑 명령어(값을 원자적으로 교환, ex: swap(a,b) ) / 2개의 인수사용 호출이전에 2번째인수=1번째인수

5.6 세마포어(상호 배제를 이루는 또 다른 방법, 철학자들의 만찬 문제 해답, 이해해둘 것.)
-보호 변수를 하나 사용하여 P와 V연산을 함(둘 중 한 연산만 접근 수정 가능, 임계영역에 들어가고 싶으면 P연산(1감소)을 호출, 임계영역을 나오고 싶으면 V연산(1증가)을 호출)
-P연산을 생략하면 상호 배제를 강제할 수 없다.
-V연산을 생략하면 P연산 때문에 대기하는 스레드들이 교착상태에 빠질 수 있다.

	세마포어 만들기까지 과정
- 임계영역 문제 해결 코드
- 상호배제 ->진행 ->제한된 대기->무한대기방지 각 기계어 명령어는 분할할수 없게 실행
	- 기계어 명렁어 분할이 안되면 flag설정할때 멋대로 임계영역에 자유롭게 접근
- 무한루프에 빠지지 않게 작은 sequence?만 interrupt disable 해야함 
- Embeded System Kernal 만질때 오류발생
- 데커알고리즘 -> 세마포어 (열차에서 아이디어)
	- 1) 아무도 임계영역 사용하지 않는데 못들어감
	- 2) 동기화 O
		- 상호배제 보장하지 않음 ->둘다 false가 되버림
		- contact switching에 따라 결과 달라짐
	- 3) 교착상태야기
		- 진입구간에서 contact Switching되면 무한대기

- 1),3)차이점 시작하는놈 지정
	- 멀티 Task 초창기 아이디어 
- 문제만들면서 제안
---
	세마포어
- 정지->진행 -> 정지 -> 진행
- Signal
- P : wait
- V : Start
- S : 세마포어를 나타내고 표준단위연산 P와 V에의해 접근되는 정수변수
	- 철로->1개 S값 == 1
	- 자원의개수 ==세마포어 개수 
	- 공유영역 1-> S값 1
	- 공유영역은 나누면 나눈만큼 늘어남
	- 나누는 작업 ==세마포어 분리 count증가하지 않음
		- 증가되면3개프로세스동시 접근하게됨
		- 다른 자원 세마포어 분리
		- 공유메모리-> 세마포어 사용
		- print -> 똑같은 자원 여러개  
- 검사 : 프로세스 깨우는 신호

---
*Q. 스레드 간 의사소통과 동기화는 비동기로 실행된느 스레드들 간에만 필요하다(X:프로세스에서도 필요)
*Q. 전반적으로 서로 독립적으로 동작하는 스레드들이라도 이따금씩 의사소통하는 경우라면 동기실행이라고 한다(X)
*Q.스레드는 한 번에 오직 한 세마포어 대기 큐에만 있을 수 있다(O)
*Q.카운팅 세마포어에서 V연산은 항상 1만 더한다(X)

#병행 프로그래밍
- 병렬성이 있는 문제를 더 자연스럽게 표현
- 여러개의 프로세스가 존재하는 하드웨어 병렬성과 분산시스템은 병행프로그래밍을 통해서만 유용하게 사용가능
- 병행 프로그래밍은 순차적 프로그래밍 보다 훨씬어렵고 복잡
	- 코딩,디버깅,수정 작업 및 정확성ㅇ르 증명하는 일은 어려운 작업
	
##모니터(Monitor) 
- 공유자원과 이것의 임계영역을 관리하는 소프트웨어 구성체
- 데이터와 프로시저를 모두 포함하는 객체, 순차적으로 재사용 가능한 특정 공유 자원
	- 데이터와 프로시저들은 특정 공유 자원을 할당하는 데 필요
	- 모니터안에서만 접근 가능
	- 모니터 밖에 있는 프로세스는 모니터에 있는 데이터 접근 불가능
	-  
- 모니터를 통한 스레드의 자원 반납
	- 새로 도착한 스레드보다 이미 대기 중인 스레드에 높은 우선순위 : **무기한연기 발생방지**
	- 모니터 진입루틴은 대기 중인 스레드 중 하나가 모니터에 들어가 자원을 얻ㅇ르 수 있도록 하는 신호(signal)을 보냄
- 모니터를 사용한 간단한 자원 할당
	- 모니터경계에서한번에한프로세스만진입하도록제어되므로상호배제를지킴.
	- 스레드는모니터를사용해자원을할당할때모니터진입루틴을호출해야함
	- 모니터가사용되고있을때들어가려는스레드는대기해야함
	- 모니터 진입 루틴 호출(안에 있는 스레드가 작업을 마칠 때 까지 스레드는 밖에서 대기)
	- 상태 변수(자원의 사용 여부를 나타냄)
- 조건 변수
	- 임계영역과 유사하며 프로세스가 실행되는 동안 상호배제와 동기화 제공
	- 조건 임계영역으로 확장되었으며,동기화를 위한 부수 기법이 필요함
	- 모니터 밖의 프로세스가 대기 시 조건 변수에 의해 수행 재개가 결정됨
	- 조건 형태의 변수 정의 가능
	- 조건 변수는 wait와 signal연산만이 호출 가능
		- 스레드가 모니터에 다시 들어가기 전에 신호를 호출한 스레드가 먼저 모니터를 빠져나가야함
		- ---
			신호 후 종료(signal-and exit)모니터
		- 스레드가 신호를 받으면 모니터를 나가는 것
		- ---
			신호 후 종료 모니터 (Signal and -continue)모니터
		- 모니터에 있는 스레드에 모니터를 곧 사용할 수 있음을 신호
		- 모니터 밖으로 나갈 때 까지 여전히 모니터에 대한 잠금을 쥐고 있게 할 수 있음
		- 스레드는 조건 변수를 대기하거나 모니터로 보호하는 코드를 모두 완료함으로써 모니터 밖으로 나갈 수 있음 
    
-wait: 자원을 사용할 수 없음을 발견한 스레드들은 이 조건 변수를 [대기] 
-siganl: 자원을 반납하는 스레드는 이 조건 변수를 [신호]
->원형 버퍼[배열사용] (교재 생산자/소비자 문제에서 사용)
-소비자: 데이터가 저장된 순서대로(FIFO) 데이터를 제거
-생산자: 배열의 마지막 칸까지 채워나감(데이터가 꽉차면 배열의 첫 번째 칸부터 데이터를 채워나감), 소비자보다 데이터를 앞서 갈 수 있음

6.3 자바 모니터
Synchronized: 자바 객체에 상호 배제 기능을 부여
자바 Wait 메소드: 호출하는 스레드가 객체에 대한 잠금을 해제
자바 Notify 메소드: 대기 집합에 있는 스레드 중 하나를 깨움(둘 이상의 스레드가 모니터에 접근할 시 유용)
자바 NotifyAll 메소드: 엔트리와 대기 집합에 있는 모든 스레드를 깨움(오버헤드가 큼)
* 정보은닉: 그냥 정보은닉 키워드가 있다는 것만 생각해 둘 것.





##조건 변수
##원격 프로시저 호출을 사용한 프로세스 간 통신에 대해 다룸





